<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0053)http://courses.cs.tamu.edu/choe/13fall/315/proj1.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>team 1: rdbms [programming studio]</title>

<meta name="author" content="jarvi,kerne">
<meta name="description" content="">
<meta name="keywords" content="">
<link href="../../../code/styles/ecologylab/courses.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="./team1_files/stylesheet.css">
<link rel="shortcut icon" href="../../../images/ecologylab-16.ico" type="image/ico">
<style >
A
{
	color: #546376;
	text-decoration: none;
}
A:hover
{
	color: #0004DC;
	text-decoration: none;
}

</style>

<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<body>
<div  class="widecontainer">

<div class="banner">
  <span class="banner_studio" >programming&nbsp;studio</span>
  <img class="studio_logo" src="../images/palette72.png" />
</div>

<div class="navigation">
<div class="block">
  <a class="navlink" href="../index.html">welcome</a>
  <a class="navlink" href="../policies.html">policies</a>
  <a class="navlink" href="../texts.html">textbooks</a>
  <a class="navlink" href="../contact.html">contact info</a>
</div>

<div class="block">
<a class="navlink" target="_blank" href="https://docs.google.com/spreadsheets/d/1Og_0o7naJWBIcbz60pseO1E2-_3LJNirDy5EIp4jDFg/edit?usp=sharing">schedule</a>
<a class="subnavtitle" href="index.html">assignments</a>
<a class="subnavlink" href="individual1.html">individual</a>
<a class="navselected" target="_blank" href="team1.html">team 1: rdbms</a>
</div>

<div class="block_ecologylab">
  <a class="top_navlink" href="../../../index.html">interface ecology lab</a>
  <a class="navlink" href="../../index.html">courses</a>
  <a class="navlink" href="../../../research/index.html">research</a>
  <a class="navlink_logo" href="../../../research/index.html"><img class="navicon" src="../../../images/interfaceEcologyLabLogoNavGuide.png"/></a>
</div>


</div>
<div class="content_title">Team Project 1: Relational Database Management System (RDBMS)</div>


<div id="content">


<div id="outline-container-1" class="outline-2">


<div id="outline-container-1.2" class="outline-3">
<h3>Project Phases</h3>
<div class="outline-text-3" id="text-1.2">
<ol style="list-style-type: upper-roman">  
<li>Implement a simple <i>database management system</i> (DBMS): deliverables 1-3.</li>
<li>Implement an example application, which calls on the DBMS system developed in Phase 1 to input, store, and manipulate data.</li>
</ol>
</div>
</div>

<div id="outline-container-0.0" class="outline-3"> 
<h3>Overview of Deliverables</h3>
<p>
See below for details of
what you need to submit for each.
</p><ol>
<li> Design documents (2/4)
</li><li> DBMS engine code (2/11)
</li><li> DML Parser integrated with DBMS Engine (2/18)
</li><li> Application Integrated with Final Parser and Engine + Report (2/25)
</li>
</ol>
<p></p>
<p>
FAQs and additional clarification:
</p><ol>
	<li> For the DBMS engine code submission (2/11), 
<b>You don't need to submit file IO functions since they require the parser.</b>
	</li><li> You <b>DO NOT</b> need to write a general parser 
	that takes in an arbitrary grammar. You just need to hard-code the 
	pseudo-SQL grammar to implement a recursive descent parser.
	<!--li> Some ER diagrams in the submitted design documents
	were conceptually broken. Rethink what should be entities and what
	should be relations and if attributes can be added to the relations
	to make more sense.<-->
	</li><li> Table implementation: Vector of vector vs. matrix? Consider tradeoffs.
	</li><li> DB app code: will be a mixture of C++ code (menu output, user input, etc.) + DML/query language code (called within the C++ code). <br/>
	Users of the DB app will not have direct access to the DML/query language.
	</li><li> <a class="destination" href="http://students.cse.tamu.edu/aalap/CSCE315_s12/sample_inputs/parser_milestone_good_inputs.txt">Test inputs for DBMS.</a> 
	</li><li> You should <b>not</b> assume that blank space is inserted between all tokens.
	</li><li> Coding style and commenting will be taken into account.
	</li><li> Read the "Deliverables" section carefully. For example, example output is required.

</li></ol>
</div>

<div id="outline-container-1.1" class="outline-3">
<h3">Team configuration </h3>
<div class="outline-text-3" id="text-1.1">


<p>
This project is a team project.
Ideal team size is four. 
If the number of students is not divisible by four, we can have a few
teams with size of three. Teams will be formed by the students within each section.
</p>
</div>

</div>


<div id="outline-container-1.3" class="outline-3">
<h3>PHASE I: Specification of the DBMS </h3>
<div class="outline-text-3" id="text-1.3">


<p>
Database management systems are very complex pieces of software.  They
support concurrent use of a database, transactions, permission
handling, query optimizations, logging, &hellip;  To be efficient,
they utilize highly tuned algorithms developed during the course of
decades. 
So for a four-week long project, we have to simplify. We thus base our DBMS on <i>relational algebra</i>. 
</p>
<p>
Relational algebra is a formal system for manipulating relations.
It consists of only six primitive operations.
Each of the operations take <i>relations</i> as arguments, and produce
a relation as a result. The operations thus compose freely.
</p>
<p>
The upside of using relational algebra is that the implementation effort of the 
DBMS stays manageable. The downside is that queries tend to be more
verbose and maybe a bit harder to construct than, say, 
with SQL.
</p>

</div>


<div id="outline-container-1.3.1" class="outline-4">
<h4>Terminology</h4>
<div>
<dl>
<dt>Database</dt><dd>
a collection of relations
</dd>
<dt>Relation</dt><dd>
a table with columns and rows
</dd>
<dt>Attribute</dt><dd>
a named column of a relation
</dd>
<dt>Domain</dt><dd>
the set of admissible values for one or more attributes
</dd>
<dt>Tuple</dt><dd>
a row of a relation (sequence of values, one for each attribute of a relation)

</dd>
</dl>
</div>

</div>


<div >
<h4>Relational algebra </h4>
<div>
<p>
The core operations of relational algebra are:
</p>
<ol>
<li>
<i>Selection:</i>  select the tuples in a relation that satisfy a particular condition.
</li>
<li>
<i>Projection:</i> select a subset of the attributes in a relation.
</li>
<li>
<i>Renaming:</i> rename the attributes in a relation. 
</li>
<li>
<i>Set union:</i> compute the union of two relations; the relations must be <i>union-compatible.</i> 
</li>
<li>
<i>Set difference:</i> compute the set difference of two relations; the relations must be <i>union-compatible.</i> 
</li>
<li>
<i>Cross product:</i> compute the Cartesian product of two relations. 
</li>
</ol>

<p>In addition to these operations, we include the <i>natural join</i>
operation.  The result of the natural join between relations <i>R</i> and <i>S</i> 
is the set of all combinations of tuples in <i>R</i> and <i>S</i> 
that are equal on their common
attribute names. The common attributes only appear once in the result.
</p>
<p>
Natural join is expressible
using the six fundamental operations, but a direct implementation for
joins can reduce the need to use the (expensive) Cartesian product
operation.
</p>
</div>

</div>


<div style="margin-top:20px;">
<h4>Grammar </h4>
<div>


<p>
The communication with the DBMS takes place using a domain-specific language.
The grammar of <i>queries</i> in this language is as follows.
</p>

<p class="verse">
<i>query</i> ::= <i>relation-name</i> <code>&lt;-</code> <i>expr</i> <code>;</code><br>
<br>
<i>relation-name</i>  ::= <i>identifier</i><br>
<br>
<i>identifier</i> ::= <i>alpha</i> { ( <i>alpha</i> <code>|</code> <i>digit</i> ) }<br>
<br>
<i>alpha</i> ::= <code>a</code> <code>|</code> ï¿½ <code>|</code> <code>z</code> <code>|</code> <code>A</code> <code>|</code> ï¿½ <code>|</code> <code>Z</code> <code>|</code> <code>_</code><br>
<br>
<i>digit</i> ::= <code>0</code> <code>|</code> ï¿½ <code>|</code> <code>9</code><br>
<br>
<i>expr</i> ::= <i>atomic-expr</i> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>|</code> <i>selection</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>|</code> <i>projection</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>|</code> <i>renaming</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>|</code> <i>union</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>|</code> <i>difference</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>|</code> <i>product</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>|</code> <i>natural-join</i><br>
<br>
<i>atomic-expr</i> ::= <i>relation-name</i> <code>|</code> <code>(</code> <i>expr</i> <code>)</code><br>
<br>
<i>selection</i> ::= <code>select</code> <code>(</code> <i>condition</i> <code>)</code> <i>atomic-expr</i><br>
<br>
<i>condition</i> ::= <i>conjunction</i> { <code>||</code> <i>conjunction</i> }<br> 
<br>
<i>conjunction</i> ::= <i>comparison</i> { <code>&amp;&amp;</code> <i>comparison</i> }<br>
<br>
<i>comparison</i> ::= <i>operand</i> <i>op</i> <i>operand</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | <code>(</code> <i>condition</i> <code>)</code><br>
<br>
<i>op</i> ::= <code>==</code> <code>|</code> <code>!=</code> <code>|</code> <code>&lt;</code> <code>|</code> <code>&gt;</code> <code>|</code> <code>&lt;=</code> <code>|</code> <code>&gt;=</code><br>
<br>
<i>operand</i> ::= <i>attribute-name</i> <code>|</code> <i>literal</i><br>
<br>
<i>attribute-name</i> ::= <i>identifier</i><br>
<i>literal</i> ::= intentionally left unspecified<br>
<br>
<i>projection</i> ::= <code>project</code> <code>(</code> <i>attribute-list</i> <code>)</code> <i>atomic-expr</i><br>
<br>
<i>attribute-list</i> ::= <i>attribute-name</i> { ,  <i>attribute-name</i> } <br>
<br>
<i>renaming</i> ::= <code>rename</code> <code>(</code> <i>attribute-list</i> <code>)</code> <i>atomic-expr</i><br>
<br>
<i>union</i> ::= <i>atomic-expr</i> <code>+</code> <i>atomic-expr</i><br>
<br>
<i>difference</i> ::= <i>atomic-expr</i> <code>-</code> <i>atomic-expr</i><br>
<br>
<i>product</i> ::= <i>atomic-expr</i> <code>*</code> <i>atomic-expr</i> <br>
<br/>
<i>natural-join</i> ::= <i>atomic-expr</i> <code>JOIN</code> <i>atomic-expr</i> <br/>
</p>

<p>
Queries generated from the above grammar compute new relations based on existing
relations. Queries can also name those new relations. 
We need, however, some ways to create some initial relations (constituting a database), 
update the relations within the database, store the results of queries back to 
the database, and delete tuples from relations.
We use the following commands for these purposes:
</p>

<p class="verse">
<i>command</i> ::= ( <i>open-cmd</i> <code>|</code>
	<i>close-cmd</i> <code>|</code>
	<i>write-cmd</i> <code>|</code>
	<i>exit-cmd</i> <code>|</code>
	<i>show-cmd</i> <code>|</code>
<i>create-cmd</i> <code>|</code> <i>update-cmd</i> <code>|</code> <i>insert-cmd</i> <code>|</code> <i>delete-cmd</i> ) <code>;</code><br>
<br>

<i>open-cmd</i> ::== <code>OPEN</code> <i>relation-name</i>
<br>

<i>close-cmd</i> ::== <code>CLOSE</code> <i>relation-name</i>
<br>

<i>write-cmd</i> ::== <code>WRITE</code> <i>relation-name</i>
<br>

<i>exit-cmd</i> ::== <code>EXIT</code> 
<br>

<i>show-cmd</i> ::== <code>SHOW</code> <i>atomic-expr</i>
<br>

<i>create-cmd</i> ::= <code>CREATE TABLE</code> <i>relation-name</i> <code>(</code> <i>typed-attribute-list</i> <code>)</code> <code>PRIMARY KEY</code> <code>(</code> <i>attribute-list</i> <code>)</code><br>
<br>
<i>update-cmd</i> ::= <code>UPDATE</code> <i>relation-name</i> <code>SET</code> <i>attribute-name</i> <code>=</code> <i>literal</i> { , <i>attribute-name</i> <code>=</code> <i>literal</i> } <code>WHERE</code> <i>condition</i> <br>
<br>
<i>insert-cmd</i> ::= <code>INSERT INTO</code> <i>relation-name</i> <code>VALUES FROM</code> <code>(</code> <i>literal</i> { , <i>literal</i> } <code>)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>|</code> <code>INSERT INTO</code> <i>relation-name</i> <code>VALUES FROM RELATION</code> <i>expr</i><br>
<br>
<i>delete-cmd</i> ::= <code>DELETE FROM</code> <i>relation-name</i> <code>WHERE</code> <i>condition</i><br>
<br>
<i>typed-attribute-list</i> ::= <i>attribute-name</i> <i>type</i> { , <i>attribute-name</i> <i>type</i> }<br>
<i>type</i> ::= <code>VARCHAR (</code> <i>integer</i> <code>)</code> <code>|</code> <code>INTEGER</code><br>
<i>integer</i> ::= <i>digit</i> { <i>digit</i> }<br>
<br>
</p>


<p>
A program in our data manipulation language (DML) is then defined as:
</p>

<p class="verse">
<i>program</i> ::= { ( <i>query</i> <code>|</code> <i>command</i> ) }<br>
</p>


</div>

</div>


<div>
<h4>Example</h4>
<div>
<pre class="example">CREATE TABLE animals (name VARCHAR(20), kind VARCHAR(8), years INTEGER) PRIMARY KEY (name, kind);

INSERT INTO animals VALUES FROM ("Joe", "cat", 4);
INSERT INTO animals VALUES FROM ("Spot", "dog", 10);
INSERT INTO animals VALUES FROM ("Snoopy", "dog", 3);
INSERT INTO animals VALUES FROM ("Tweety", "bird", 1);
INSERT INTO animals VALUES FROM ("Joe", "bird", 2);

SHOW animals;

dogs &lt;- select (kind == "dog") animals;
old_dogs &lt;- select (age &gt; 10) dogs;

cats_or_dogs &lt;- dogs + (select (kind == "cat") animals);

CREATE TABLE species (kind VARCHAR(10)) PRIMARY KEY (kind);

INSERT INTO species VALUES FROM RELATION project (kind) animals;

a &lt;- rename (aname, akind) (project (name, kind) animals);
common_names &lt;- project (name) (select (aname == name &amp;&amp; akind != kind) (a * animals));
answer &lt;- common_names;

SHOW answer;

WRITE animals;
CLOSE animals;

EXIT;

</pre>

<p>
Note that we made a distinction between queries and commands in the grammar of the DML.
The result of a query is a <i>view</i>. A view is
not stored in the database. Rather, it is a temporary relation whose lifetime
ends when a DML program finishes. So only the updates caused by the
commands persist from one DML program execution to another.
</p>
<p>
The relations themselves should be saved in a file in plain ASCII text (<b>DO NOT use binary</b>), using the
same DML described above (e.g., CREATE ... INSERT ... INSERT .... ). To make it simple, let us assume that each database file can only store one relation and the filename is the same as the relation name with the suffix ".db". To load a relation from a database file, use the OPEN command. Opening a nonexisting file will result in nothing. To create a new relation file, use the WRITE command (the filename will be by default "relationname.db"). To save all changes to the relation in a database file and close, use the CLOSE command. 
</p>
<p>
To exit from the DML interpreter, use the EXIT command.
</p>
<p>
To print a certain relation or a view, use the SHOW command.
</p>

</div>
</div>

</div>

<div style="margin-top:35px;">
<h3>PHASE II: DB Application </h3>
<div>

The second phase of this project is to write a simple DB application
written in the DML described above. The DB app will run on your DB engine.
Since you will need to take user I/O and implement a custom control
flow (conditional statements, loops, etc.), the DML described above alone
is not enough. Instead of extending the DML to include such non-DB commands,
you will use a host language (e.g., C++) to interact with your DBMS.
<p>
The host program will provide most of the user interface: displaying menus,
taking user input, and showing results. Based on these user inputs, a custom
query or command string can be generated and passed on to the DBMS to be parsed
and executed..
</p><p>
<b>As needed</b>: You may also need to retrieve the results of 
the queries to feed into
the host language's control flow. The DBMS object can contain a member function
to access the relations, views, and the attributes by their name (string).
</p><p>
Here is an example interaction:
</p>

<pre class="src src-C++">string name;
cin &lt;&lt; name;

string query = string(<span style="font-style: italic;">""</span>) + 
               <span style="font-style: italic;">"answer &lt;- project (age) ( select (kind == \"dog\" &amp;&amp; name == "</span> + name + <span style="font-style: italic;">") animals )"</span>;

rdbms.execute(query);

if (rdbms.relation(relation_name).int_field(field_name) == 10) {
	...
}

</pre>

The DB application itself will be of your own design, with the following requirements: 
<ol>
	<li> The application domain is open-ended: bank, web forum, 
		warehouse app, point-of-sale, auto maintenance shop,
		etc., but it CANNOT BE one of the following: DVD or any kind of rental app, Library app, or PDA app. 
	</li>
	<li> The domain needs to be sufficiently complex. 
	It should include at 
	least three entities and two relations (a total of five relational tables,	minimum). 
	Thus, having a single table (e.g., a simple TODO 
	list, etc.) is not acceptable.
	</li><li> The following command/query needs to be used at least once.
	<ul>
		<li> open, close, write, exit, show
		</li><li> create table, insert into, update, delete
		</li><li> select, project, +, - , * (note: you have to think hard
			how to utilize all these in Phase II)
	</li></ul>
	</li><li> Provide a rough sketch of your application and its functionality
		in your design document. We will provide you with feedback 
		in case it is too simple or too complex so that you can
		revise your plan early on.
</li></ol>

As an example, here's a spec from a previous semester. This was for a DVD rental shop. Think about what should be an entity and what should be a relation.
<ol>
	<li> Customer data: USER-ID, Firstname, Lastname, Phone Number
	</li><li> DVD data: Inventory number, DVD-ID, Title
	</li><li> Rental log: USER-ID, Inventory number, Check out date, Due date 
	</li><li> Operations: Add new customer, Add new DVD, 
		Remove customer, Remove DVD,
		Update customer, Update DVD,
		List customer, Search customer (by name, phone), 
		List DVD, Search DVD (by ID, title), Search inventory,
		Check out DVD, Check in DVD, Show rental list by customer,
		Show customer list by DVD-ID.
	</li><li> The user interface can be a simple scrolling text with CLI (command-line
		interface) that prints the
		menu and takes user input from the keyboard.
</li></ol>
Note that most of the code in the host language will be user interface, as
you will be able to use the DML for most of the required operations.

<!--
-->

</div>

</div>

<div style="margin-top:25px;">
<h3>Requirements and Deliverables</h3>
<div>
<ul>
</li><li> Each team should maintain a development log (Google doc or similar) 
	updated by
	the team members. Give access to the TA.
	This log will be graded. There is no designated format. We will
	check your daily progress. Update your log daily.
	</li>
	<li> Perform unit testing for major routines using a test driven development framework, such as Visual Studio test system, NUnit, Boost Test, and Googletest.
	Since you need to do this, engagement in test driven development is strongly encouraged!
	</li>
	<li> Expect to be called on to demo in the lab for deliverables 3 and 4.
	</li>
</ul>
<ol>
<li> Design documents: Follow the guidelines in <a target="blank" class="destination" href="http://blog.slickedit.com/2007/05/how-to-write-an-effective-design-document/">Scott' Hackett's "How to Write an Effective Design Document" (Writing for a Peer Developer)</a>. Include all four sections described in the guide.
<ul>
	<li> The design document should cover both Phase I (DB engine) and
		Phase II (DB app).
	</li><li> Phase II documents should include ER diagram and corresponding 
		relation schema, besides other things.
</li></ul>
</li><li> DBMS engine code: This will be the core DB function library, without the parser.
	<ul> <li>Upload your DBMS engine library code.  
	</li><li>
	You should include a test application that tests all functionality (function calls relating to all queries, all commands).
	</li><li> Also submit the input and output (text file) from your test 
		application.
	</li><li> <b>You may omit the file I/O code since it requires the parser.</b>
	</li><li> Theoretically, you should be able to build a DB app just using this
		library. (However, we will not do this -- you will use the
		DML command-line for the most part and not directly call the
		DBMS library functions from your final DB app.)
	</li></ul>
</li><li> DML Parser integrated with DBMS Engine: Upload completed DBMS system code, including parser. 
It should be able to take input from the keyboard and accept or reject an arbitrary command or query.
 Accept syntactically correct
commands or queries. Reject anything that violates the syntax.
	<ul> 
	<li> Upload your parser code.
	</li>
	<li>Submit the input and output (text file) of your parser.
	</li>
	<li> Keep in mind how you will later integrate your parser code with the
	DB engine as you write the parser code.
	<li>Provide a CLI (command-line interface) where you
		can type in the commands and queries and it should be fully
		functional as a DB.
	</li>
	<li> Include example inputs and actual outputs from your DBMS.</li>
</ul>
</li>

<li> Final project code + DB application code + report.
Provide all source code and a stand-alone executable. The report should include: 
<ul><li>Updated version of your design document
</li><li>Post-production notes (changes you had to make to your design and why, difficulties, solutions, lessons learned)
</li><li>Individual work load distribution (percentage) -- how much of the total work did you and each of your teammates perform?
</li><li> Development log.
</li><li>A log of an example session with your DB application: show menu, take user input, application's output and messages, etc.
</li><li> The following must be submitted individually: 
<ul><li>
Self Evaluation: honestly rate your performance on the scale of 1 to 5, 5 being the best. Briefly discuss how you contributed to the project.
</li><li> Peer Evaluation: honestly rate all other team members on the scale of 1 to 5, 5 being best. For each member, briefly comment on their contribution.
If you disagree with the work load distribution reported by the team, make this explicit. Provide your version, and written explanation of what went down.
</li><li> Your team performance on this project will impact our decisions about team formation for future assignments.
Please let us know if there are any signifiant issues about your current team. 
If you want to leave your team, or would not want to work with any particular members again, indicate so and provide justification in writing.
</li></ul>
</li></ul>
</li></ol>


<div>
<h4>Extra Credit (optional)</h4>
<div>
In addition to building the full project as a team, partner with another team.
Port  your DB app, with the same functionality, to use the other team's Phase I code.
Total value: 10 points.<br/>
Include a short report about what issues arose and what you learned while porting your application to their DBMS.

<div style="margin-top:35px;">
<h4 id="sec-1.5.5">Submission</h4>
<div class="outline-text-4" id="text-1.5.5">

<p>
All project deliverable submissions must be through <a class="destination" target="_blank" href="https://csnet.cs.tamu.edu">https://csnet.cs.tamu.edu</a>.
</p>

<p>
<b>Except for the individual peer evaluation deliverable, only one person from your team may submit, as a designated submitter. All other submissions will be ignored.</b> 
</p>

<p>
See <a class="destination" href="../policies.html">policies web page</a> for information on late penalties.
</p>
</blockquote>

</div>
</div>

</div>
</div>
<div id="postamble">
<p>

Original concept/design/most of the text by Jaakko J&#228;rvi. Modifications by Andruid Kerne and Yoonsuck Choe.

</p></div></div>
</div>
</div>
</div>

</div></div></div></body></html>
